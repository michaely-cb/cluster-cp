# Playbook to apply all patches and Mellanox driver on user node
# Based on apply_all_updates.yaml
- name: Copy 100G renaming script
  copy:
    src: set_nic_name.py
    dest: /tmp/set_nic_name.py
    mode: '0755'

# Fix existing 100G network interface names to prevent changes due to
# Mellanox driver installation.
- name: Fix existing 100G network interface names
  ansible.builtin.command: python3 /tmp/set_nic_name.py fix_100g

- name: Remove set_nic_name script
  ansible.builtin.file:
    path: /tmp/set_nic_name.py
    state: absent

- include_tasks: fix_k8s_repo.yaml

- name: Create cerebras-patches.repo file
  ansible.builtin.copy:
    content: |  
      [cerebras-patches]  
      name=Security Patches for Cerebras Clusters  
      baseurl=http://{{ deploy_server }}:8080/repo/Cerebras-patches
      module_hotfixes=true
    dest: /etc/yum.repos.d/cerebras-patches.repo  
    owner: root  
    group: root  
    mode: '0644'  

- name: Apply patches on servers
  ansible.builtin.command:
    # --skip-broken --nobest to skip any broken packages, in case the end-user
    # has installed some incompatible packages.
    # It would be nice though to be able to report these issues at the end.
    cmd: dnf upgrade --refresh --repo cerebras-patches --skip-broken --nobest --assumeyes

- name: Install new packages
  ansible.builtin.command: dnf install --repo cerebras-patches --skip-broken --nobest --assumeyes '*' 

- name: Remove cerebras-patches.repo
  ansible.builtin.file:
    path: /etc/yum.repos.d/cerebras-patches.repo
    state: absent

- name: Define python 3.11 package directory
  ansible.builtin.set_fact:
    python_packages: http://{{ deploy_server }}:8080/repo/Cerebras-patches/packages

- name: Check if python packages directory exists, upgrade to python 3.11 if it exists
  uri:
    url: "{{ python_packages }}"
    method: GET
    return_content: no
  register: http_response
  failed_when: "http_response.status != 404 and http_response.status != 200"

- name: Store status code in variable
  set_fact:
    python_packages_exist: "{{ http_response.status == 200 }}"

- name: Copy python 3.11 package requirements.txt
  ansible.builtin.get_url:
    url: "{{ python_packages }}/requirements.txt"
    dest: /tmp/requirements.txt
  when: python_packages_exist

- name: Set up python 3.11 pip
  ansible.builtin.shell:
    cmd: |
      python3.11 -m ensurepip
      python3.11 -m pip install --upgrade pip --no-index -f {{ python_packages }} --trusted-host {{ deploy_server }}
  when: python_packages_exist

- name: Deploy python 3.11 packages
  ansible.builtin.command: python3.11 -m pip install -r /tmp/requirements.txt --no-index -f {{ python_packages }} --trusted-host {{ deploy_server }}
  when: python_packages_exist

- name: Clean up requirements.txt
  file:
    path: /tmp/requirements.txt
    state: absent
  when: python_packages_exist

- name: Set python3 to python 3.11
  ansible.builtin.command: update-alternatives --set python3 /usr/bin/python3.11
  when: python_packages_exist

- name: Check if awscli package exists
  # We may use the latest script to work on older Cerebras-patches tarball,
  # which may not have the awscli zip file yet.
  ansible.builtin.shell:
    cmd: curl -s http://{{ deploy_server }}:8080/repo/Cerebras-patches/ | grep 'awscli-exe-linux-x86_64.zip' | cut -d '"' -f 8
  register: awscli_file
  run_once: true

- name: Create tmp directory for installing awscli v2
  file:
    path: /tmp/awscli
    state: directory
    mode: '0755'
  when: awscli_file.stdout != ""

- name: Copy and unzip awscli v2
  unarchive:
    src: http://{{ deploy_server }}:8080/repo/Cerebras-patches/awscli-exe-linux-x86_64.zip
    dest: /tmp/awscli
    remote_src: yes
  when: awscli_file.stdout != ""

- name: Install/Update awscli v2
  command:
    cmd: ./install --update
    chdir: /tmp/awscli/aws
  when: awscli_file.stdout != ""

- name: Validate awscli v2 is installed properly
  command: /usr/local/bin/aws --version
  register: command_result
  failed_when: command_result.rc != 0
  when: awscli_file.stdout != ""

- name: Clean up awscli tmp directory
  file:
    path: /tmp/awscli
    state: absent
  when: awscli_file.stdout != ""

- name: Create temporary driver directory
  ansible.builtin.tempfile:
    state: directory
    suffix: driver
  register: driver

- name: Determine Mellanox driver filename
  ansible.builtin.shell:
    cmd: curl -s http://{{ deploy_server }}:8080/repo/Cerebras-patches/ | grep 'MLNX' | cut -d '"' -f 8
  register: driver_file

- name: Copy Mellanox driver to server
  ansible.builtin.get_url:
    url: 'http://{{ deploy_server }}:8080/repo/Cerebras-patches/{{ driver_file.stdout }}'
    dest: '{{ driver.path }}'

- name: Find the name of the Mellanox .tgz file
  ansible.builtin.find:
    paths: '{{ driver.path }}'
    patterns : 'MLNX_*.tgz'
    file_type: file
  register: tar_file

- name: Unarchive Mellanox driver
  ansible.builtin.unarchive:
    src: '{{ tar_file.files[0].path }}'
    dest: '{{ driver.path }}'
    remote_src: yes
  register: untar_out

- name: Find the extracted directory
  ansible.builtin.find:
    paths: '{{ driver.path }}'
    patterns : 'MLNX_*'
    file_type: directory
  register: extracted_dir

- name: Find the latest installed kernel version
  ansible.builtin.shell:
    cmd: find /boot/vmlinuz-* | sort -V | tail -n 1 | sed 's|.*vmlinuz-||'
  register: kernel_version

- name: Install Mellanox driver
  ansible.builtin.shell:
    cmd: ./mlnxofedinstall --force --without-fw-update -q -k {{ kernel_version.stdout }} -s /lib/modules/{{ kernel_version.stdout }}/build
    chdir: '{{ extracted_dir.files[0].path }}'

- name: Clean up
  ansible.builtin.file:
    path: '{{ driver.path }}'
    state: absent

- name: Rebuild boot image
  ansible.builtin.command: dracut -f --kver {{ kernel_version.stdout }}

- name: Check if reboot required
  ansible.builtin.command: "needs-restarting -r"
  changed_when: false
  failed_when: reboot_required.rc != 0 and reboot_required.rc != 1
  check_mode: false
  register: reboot_required

- name: Restart Mellanox driver if no reboot needed
  ansible.builtin.command: /etc/init.d/openibd restart
  when: reboot_required.rc == 0

- name: Check if /etc/rc.d/rc.local exists when no reboot is needed
  stat:
    path: /etc/rc.d/rc.local 
  register: rc
  when: reboot_required.rc == 0

- name: Re-enable RoCE if no reboot is needed
  ansible.builtin.command: bash /etc/rc.d/rc.local 
  when: reboot_required.rc == 0 and rc.stat.exists
