#!/usr/bin/python3.11
"""
Parallel PSSH implementation using asyncssh
Accepts some args from pscp: -p, -h, -e, -o
Handles -r
Ignores -h, always disables key checking for now
"""

import argparse
import asyncio
import os
import sys
import time
from typing import List

import asyncssh

# pssh args used:
# all -
# -p NUM_THR
# -i key
# -h hostlist
# src and dest files
# in some tests -
# -e logdir/ (stderr)
# -o logdir/ (stdout, makes files called host.count, where count is number of times host contacted during this run?)


async def run_client(
    host: str, args: argparse.Namespace, ssh_args: argparse.Namespace, ssh_options: dict
) -> asyncssh.SSHCompletedProcess:
    # asyncssh gives some args 3 states:
    # the value (string or list) you specified
    # None value you specified (disables host key checking, uses no key files, etc)
    # (), typically by not giving the optional arg (does default thing, like searching standard keys)

    if ssh_args.i:  # identity_file
        ck_arg = ssh_args.i
    else:
        ck_arg = ()

    if ssh_options.get("StrictHostKeyChecking") == "no":
        kh_arg = None
    else:
        kh_arg = ()

    async with asyncssh.connect(
        host,
        known_hosts=kh_arg,
        client_keys=ck_arg,
        connect_timeout=ssh_options.get("Timeout", args.timeout),
    ) as conn:
        return await conn.run(args.cmd)


async def run_multiple_clients(
    hostlist: List[str], args: argparse.Namespace, ssh_args: argparse.Namespace, ssh_options: dict
) -> None:
    tasks = (run_client(host.rstrip(), args, ssh_args, ssh_options) for host in hostlist)
    results = await asyncio.gather(*tasks, return_exceptions=True)

    for i, result in enumerate(results, 1):
        tstr = time.strftime("%H:%M:%S", time.localtime())
        if isinstance(result, Exception):
            print(f"[{i}] {tstr} [FAILURE] {hostlist[i-1].rstrip()} {str(result)}")
        elif result.exit_status != 0:
            print(
                f"[{i}] {tstr} [FAILURE] {hostlist[i-1].rstrip()} Exited with error code {result.exit_status}"
            )
            if args.outdir:
                with open(os.path.join(args.outdir, hostlist[i - 1].rstrip()), "w") as f:
                    f.write(result.stdout)
            if args.errdir:
                with open(os.path.join(args.errdir, hostlist[i - 1].rstrip()), "w") as f:
                    f.write(result.stderr)
            if args.inline:
                # this should be interleaved
                print(result.stdout)
                print(result.stderr)
        else:
            print(f"[{i}] {tstr} [SUCCESS] {hostlist[i-1].rstrip()}")
            if args.outdir:
                with open(os.path.join(args.outdir, hostlist[i - 1].rstrip()), "w") as f:
                    f.write(result.stdout)
            if args.errdir:
                with open(os.path.join(args.errdir, hostlist[i - 1].rstrip()), "w") as f:
                    f.write(result.stderr)
            if args.inline:
                # this should be interleaved
                print(result.stdout)
                print(result.stderr)


if __name__ == '__main__':
    # This parser is really nasty. pssh/pscp has its own set of options.
    # pssh can passthrough arbitrary ssh options inside -x.
    # And the command to run by ssh can take any args as well.
    # argparse is too greedy, so if any of the pssh args appear inside -x or the ssh command,
    # argparse will consume them and get confused.
    # Also since our ssh library doesn't understand the ssh -o Options, we need to parse those
    # and handle them in the right way for asyncssh.

    # So: first create argparsers for pssh, and for ssh-style -o Options
    # But first scan argv split the args up into pssh vs ssh args, and then the command.
    # Don't forget that the pssh args can be in the form -t 30, or --timeout=30 !
    # Then run the two argparsers.

    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument(
        '-p', '--processes', type=int, default=4, help='Number of pscp processes to use (ignored)'
    )
    parser.add_argument('-h', '--host-list', required=True, help='List of source/dest hosts')
    parser.add_argument('-e', '--errdir', help='Directory to store stderr output')
    parser.add_argument('-o', '--outdir', help='Directory to store stdout output')
    parser.add_argument(
        '-i', '--inline', action='store_true', help='inline aggregated output and error'
    )
    parser.add_argument('-t', '--timeout', help='Timeout (ignored)')
    parser.add_argument('--help', help='Show help')

    ssh_parser = argparse.ArgumentParser(add_help=False)
    ssh_parser.add_argument('-o', action='append')
    ssh_parser.add_argument('-i')

    pssh_argv = []  # -p, -h, etc
    ssh_argv = []  # -o Foo=Bar
    pssh_cmd = []  # cat /proc/kmem

    pssh_unary = "--version --help -v --verbose -A --askpass -i --inline --inline-stdout -I --send-input -P --print".split()
    pssh_binary = "-h --hosts -H --host -l --user -p --par -o --outdir -e --errdir -t --timeout -O --option".split()
    pssh_extra = "-x --extra-args -X --extra-arg".split()
    i = 1
    while i <= len(sys.argv[1:]):
        if sys.argv[i] in pssh_unary:
            pssh_argv.append(sys.argv[i])
            i += 1
        elif sys.argv[i].split('=')[0] in pssh_binary:
            pssh_argv.append(sys.argv[i])
            i += 1
            if '=' not in sys.argv[i - 1]:  # like --timeout 300  instead of --timeout=300
                pssh_argv.append(sys.argv[i])
                i += 1
        elif sys.argv[i] in pssh_extra:
            ssh_argv += sys.argv[i + 1].split()
            i += 2
        else:
            pssh_cmd = sys.argv[i:]
            break

    args = parser.parse_args(pssh_argv)

    if args.help:
        parser.print_help()
        sys.exit(0)

    if args.processes < 1:
        print("Process count must be greater than 0.", file=os.stderr)
        sys.exit(1)

    setattr(args, "cmd", ' '.join(pssh_cmd))

    ssh_args = ssh_parser.parse_args(ssh_argv)
    ssh_options = {}
    if ssh_args.o:
        for sopt in ssh_args.o:
            k, v = sopt.split('=')
            ssh_options[k] = v

    with open(args.host_list, "r") as f:
        hostlist = f.readlines()

    if args.errdir:
        os.mkdir(args.errdir)
    if args.outdir:
        os.mkdir(args.outdir)

    asyncio.get_event_loop().run_until_complete(
        run_multiple_clients(hostlist, args, ssh_args, ssh_options)
    )
