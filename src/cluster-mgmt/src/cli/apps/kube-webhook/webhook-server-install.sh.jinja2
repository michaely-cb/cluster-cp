#!/usr/bin/env bash

SCRIPT_PATH=$(dirname "$0")
cd "$SCRIPT_PATH"
source "../pkg-common.sh"

# cleanup legacy webhook
kubectl delete mutatingwebhookconfigurations kube-webhook-adjust-memory --ignore-not-found &>/dev/null

# Determine the type of cluster setup
is_single_cs_or_node=$( { ! has_multiple_systems || ! has_multiple_nodes; } && echo "true" || echo "false" )
is_not_kind_cluster=$([ ! -d /kind ] && echo "true" || echo "false")
is_not_ceph_installed=$(has_multiple_mgmt_nodes && echo "false" || echo "true")

set -e

deploy() {
  # Deploys kube-webhook. We generate a TLS key/cert pair and add it to a secret
  # and add the cert to the webhook configuration. In the case of a pre-existing
  # deployment, the cert will only be regenerated if the configuration file for
  # generating the cert changed (cfg-hash annotation on the secret mismatches
  # the hash of the current config file). This prevents unnecessary redeploys
  # which could cause lower availability of the webhook.

  OLD_TLS_CFG_HASH=$(kubectl get secret -n kube-system kube-webhook --ignore-not-found -ojsonpath='{.metadata.annotations.cfg-hash}')
  TLS_CFG_HASH=$(md5sum - <webhook-server-tls.conf | cut -d' ' -f1)

  if [ "${OLD_TLS_CFG_HASH}" = "${TLS_CFG_HASH}" ]; then
    TLS_CRT=$(kubectl get secret -n kube-system kube-webhook -ojsonpath='{.data.tls\.crt}')
    TLS_KEY=$(kubectl get secret -n kube-system kube-webhook -ojsonpath='{.data.tls\.key}')
  else
    openssl req -x509 -newkey rsa:4096 -keyout tls.key -out tls.crt -days 3650 -nodes -config webhook-server-tls.conf -extensions req_ext
    TLS_CRT=$(base64 -w0 <tls.crt)
    TLS_KEY=$(base64 -w0 <tls.key)
    rm tls.crt tls.key
  fi

  replicas=1
  if has_multiple_mgmt_nodes; then
    replicas=2
  fi
  genoa_server="false"
  if is_genoa_server; then
    genoa_server="true"
  fi

  function _template() {
    TLS_CRT_HASH=$(md5sum - <<<"${TLS_CRT}" | cut -d' ' -f1) \
    TLS_CFG_HASH=${TLS_CFG_HASH} \
    TLS_CRT=${TLS_CRT} \
    TLS_KEY=${TLS_KEY} \
    REPLICA_COUNT=${replicas} \
    GENOA_SERVER=${genoa_server} \
      envsubst
  }

  _template < webhook-server-template.yaml >webhook.yaml
  _template < webhook-systemdeployadmission-template.yaml >webhook-systemdeployadmission.yaml
  _template < webhook-adjust-resource-template.yaml >webhook-adjust-resource.yaml
  _template < webhook-add-ingress-annotation-template.yaml >webhook-add-ingress-annotation.yaml

  # skip admission validation, for local test purpose only
  if [ -d /kind ]; then
    yq eval -i 'del(select(documentIndex == 5))' webhook.yaml
  fi

  kubectl apply -f webhook.yaml
  sleep 1
  kubectl rollout status deployment/kube-webhook -n kube-system

  # In single node/system, non-kind, non-ceph clusters, only create add-ingress-annotation.
  if $is_single_cs_or_node && $is_not_kind_cluster && $is_not_ceph_installed ; then
    kubectl apply -f webhook-add-ingress-annotation.yaml
  else
    if get_disable_system_namespace_webhook ; then
      echo "skip installing system namespace deploy admission webhook due to cluster property"
      kubectl delete -f webhook-systemdeployadmission.yaml || true
    else
      kubectl apply -f webhook-systemdeployadmission.yaml
    fi
    kubectl apply -f webhook-adjust-resource.yaml
    kubectl apply -f webhook-add-ingress-annotation.yaml
  fi
}

deploy
