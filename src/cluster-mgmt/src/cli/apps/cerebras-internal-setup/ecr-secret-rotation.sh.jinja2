#!/usr/bin/env bash

SCRIPT_PATH=$(dirname "$0")
cd "$SCRIPT_PATH"
source "../pkg-common.sh"

set -e

if [ -z "${namespace}" ]; then
  namespace="{{ ns }}"
  if [ -z "${namespace}" ]; then
    namespace=$SYSTEM_NAMESPACE
  fi
fi

## If cluster has_aws_ecr_credential, it would be used to retrieve ECR token directly.
## If not, then falling back to NFS (or host-file).
additional=""
has_aws_ecr_credential=$(kubectl get secret -n "${namespace}" aws-ecr-credential 1>/dev/null 2>/dev/null && echo "true" || echo "false")
if ${has_aws_ecr_credential} ; then
  echo "installing regcred refresh with AWS ECR credential"
  additional+="--set hasAwsEcrCredential=true "
else
  ## Note on use of NFS server name:
  ##   - Check the pkg-properties first, and use the value there if it is set
  ##   - If not, check whether `cerebras-storage` is available in the cluster
  ##   - Otherwise, check the /etc/fstab file for an entry that looks like "/cb"
  ##   - If none of the above are set, fallback to the host-file method (i.e. don't use NFS)

  ## Defaults to use, if not overridden by cluster properties
  default_nfs_server_address="cerebras-storage"
  default_nfs_mount_path="/cb"
  default_nfs_sub_path="ecr-token"

  if [ -n "{{ nfs }}" ]; then
    echo "Warning: ignoring the NFS server passed in cli args to deploy ({{ nfs }})"
  fi

  ## Determine the NFS server address to use
  CB_NFS_IP=$(get_nfs_server_address)
  if [ -n "$CB_NFS_IP" ]; then
    echo "using NFS server from cluster properties: $CB_NFS_IP"
  fi

  if [ -z "$CB_NFS_IP" ]; then
    if ping -c 4 -W 2 $default_nfs_server_address &>/dev/null; then
      echo "using default NFS server $default_nfs_server_address because it is reachable"
      CB_NFS_IP=$default_nfs_server_address
    else
      echo "Warning: default NFS server $default_nfs_server_address is not reachable"
    fi
  fi

  if [ -z "$CB_NFS_IP" ] ; then
    CB_NFS_IP=$(cat /etc/fstab | grep -E '^([[:digit:]]{1,3}\.){3}[[:digit:]]{1,3}:/cb /cb' | cut -d: -f1)
    echo "Using NFS server from /etc/fstab: $CB_NFS_IP"
  fi

  ## Determine whether using overrides for mount-path and sub-path
  if [ -n "$CB_NFS_IP" ]; then
    # For mount-path and sub-path, use override from cluster properties if present, otherwise use default
    nfs_path=$(get_cluster_properties | jq -r '.properties.clusterMgmt.nfsServer.path // empty')
    if [ -z "$nfs_path" ]; then
      nfs_path="$default_nfs_mount_path"
    fi
    echo "Using NFS mount path: $nfs_path"

    nfs_sub_path=$(get_cluster_properties | jq -r '.properties.clusterMgmt.nfsServer.subPath // empty')
    if [ -z "$nfs_sub_path" ]; then
      nfs_sub_path="$default_nfs_sub_path"
    fi
    echo "Using NFS sub path: $nfs_sub_path"
  fi

  CB_HOST_FILE="false"
  if find /cb/ecr-token/config.json -mtime -1 &>/dev/null; then
    CB_HOST_FILE="true"
  fi

  if [ -z "$CB_NFS_IP" ] && ! $CB_HOST_FILE ; then
    # cleanup if exists from previous installation at cerebras datacenter
    if helm list -n "${namespace}" | grep -q regcred-refresh; then
      helm uninstall -n "${namespace}" regcred-refresh
    fi
    exit 0
  else
    if [ -n "${CB_NFS_IP}" ] ; then
      echo "installing regcred refresh with nfs IP: '${CB_NFS_IP}'"
    else
      echo "installing regcred refresh mounting host filesystem"
    fi
    additional+="--set nfsServer=${CB_NFS_IP} "
    additional+="--set nfsPath=${nfs_path} "
    additional+="--set nfsSubPath=${nfs_sub_path} "
  fi
fi

has_token=$(kubectl get secret -n "${namespace}" regcred --ignore-not-found -ojsonpath='{.data.\.dockerconfigjson}')
has_token=$(test -n "$has_token" && echo "true" || echo "false")
tag=$(get_image_version alpine-kubectl)

helm upgrade --install --wait --timeout 2m --atomic --debug --namespace "${namespace}" \
    --set namespace="${namespace}" \
    -f "regcred-refresh/values.yaml" \
    --set imageRef="${registry_url}/alpine-kubectl:${tag}" \
    ${additional} \
    regcred-refresh regcred-refresh

if ! ${has_token} ; then
  # Run initial job to instantiate the secret for future image pulls
  kubectl delete job init-regcred -n "${namespace}" --ignore-not-found
  kubectl create job init-regcred -n "${namespace}" --from=cronjob/regcred-refresh
  if ! kubectl wait --for=condition=complete -n "${namespace}" --timeout=1m job/init-regcred; then
    echo "Warning: init-regcred job failed" >&2
    kubectl -n "${namespace}" describe po -l job-name=init-regcred >&2
    kubectl -n "${namespace}" describe job/init-regcred >&2
    kubectl -n "${namespace}" logs -l job-name=init-regcred >&2
    exit 1
  fi
  kubectl delete job init-regcred -n "${namespace}" --ignore-not-found
fi
