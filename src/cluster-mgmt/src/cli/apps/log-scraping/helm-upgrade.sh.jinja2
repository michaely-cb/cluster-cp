#!/usr/bin/env bash

SCRIPT_PATH=$(dirname "$0")
cd "$SCRIPT_PATH"
source "../pkg-common.sh"
set -e

function create_storage_dir() {
  # setup mount storage path with correct permission
  PSSH_MGMT "sh -c 'mkdir -p {{ remote_storage_path }} && chown -R 10001:10001 {{ remote_storage_path }}'"
}

if is_incremental_deploy; then
  if ! has_multiple_mgmt_nodes; then
    create_storage_dir
  fi
  exit 0
fi

# unpackage charts
rm -rf ./charts
mkdir -p ./charts
tar xfz ./{{ loki_pkg_name }}-{{ loki_pkg_version }}.tgz -C charts
tar xfz ./{{ fluentbit_pkg_name }}-{{ fluentbit_pkg_version }}.tgz -C charts

values_override=""
# deploy loki
if ! has_multiple_mgmt_nodes; then
  # skip multus svc for single mgmt node as nginx don't have multus setup
  values_override+="--set singleBinary.initContainers=null "
  kubectl apply -f ./loki/hostpath-pv.yaml
  values_override+="-f ./loki/values-override.yaml "
  create_storage_dir
else
  # replace default headless service with multus-service on data-network
  cp loki/multus-service.yaml charts/loki/templates/single-binary/service-headless.yaml
  pv_size=$(get_loki_pvc_size)
  if kubectl get pvc -nloki storage-loki-0 &>/dev/null; then
    # sts spec pv size field immutable but patching pvc directly works
    kubectl patch pvc/storage-loki-0 -nloki --patch "{\"spec\": {\"resources\": {\"requests\": {\"storage\":\"${pv_size}\"}}}}"
    pv_size=$(kubectl get sts -nloki loki -ojson | jq .spec.volumeClaimTemplates[0].spec.resources.requests.storage -r)
  fi
  sed "s/loki-pvc-size/${pv_size}/g" <./loki/values-override-multi-nodes.yaml >./loki/values-override-multi-nodes.resolved.yaml
  values_override+="-f ./loki/values-override-multi-nodes.resolved.yaml "
fi

# todo: configure as HA
# todo: add limit after more usage experience with exporting all wsjob logs
NODE_COUNT=$(get_node_count)
MEM_MI=2000
if ((MEM_MI < 40 * NODE_COUNT)); then
  MEM_MI=$((40 * NODE_COUNT))
fi

echo "Helm Upgrade loki"
helm upgrade loki ./charts/{{ loki_pkg_name }} \
  --install --create-namespace --wait --timeout 300s \
  --version {{ loki_pkg_version }} --namespace loki \
  -f ./loki/values.yaml ${values_override} \
  --set ingress.hosts[0]=loki.$cluster_name.$service_domain \
  --set ingress.tls[0].hosts[0]=loki.$cluster_name.$service_domain \
  --set singleBinary.resources.requests.memory=${MEM_MI}Mi \
  --set loki.image.registry=$registry_url \
  --set loki.image.repository={{ loki_image.short_repo }} \
  --set loki.image.tag={{ loki_image.tag }} \
  --set loki.retention_period="$(get_loki_retention_period)"

# ensure retain pv
if kubectl get pvc -nloki storage-loki-0 &>/dev/null; then
  # ensure retain pv
  loki_pv=$(kubectl get pvc -nloki storage-loki-0 -ojsonpath='{.spec.volumeName}')
  if [ -n "${loki_pv}" ]; then
    kubectl patch pv "${loki_pv}" -p '{"spec":{"persistentVolumeReclaimPolicy":"Retain"}}'
  fi
fi

if has_multiple_mgmt_nodes; then
  # use the multus data network
  sed "s/LOKI_SVC/loki-headless.loki/" ./fluent-bit/values.yaml >./fluent-bit/values.resolved.yaml
else
  sed "s/LOKI_SVC/loki.loki/" ./fluent-bit/values.yaml >./fluent-bit/values.resolved.yaml
fi
echo "Deploy Fluent Bit"
helm upgrade fluent-bit ./charts/{{ fluentbit_pkg_name }} \
  --install --create-namespace --wait --timeout 5m \
  --version {{ fluentbit_pkg_version }} --namespace fluent-bit \
  -f ./fluent-bit/values.resolved.yaml \
  -f ./fluent-bit/values-override.yaml ${additional} \
  --set image.repository=$registry_url/{{ fluentbit_image.short_repo }} \
  --set image.tag={{ fluentbit_image.tag }}
# the wait is needed because helm doesn't wait for daemonsets to be ready on initial install - chart bug?
if ! await_ds_ready "fluent-bit" "fluent-bit" 300; then
  echo "Pods for fluent-bit failed to reach readiness after 5 minutes"
  exit 1
fi
echo "Deploy Fluent Bit Success"
