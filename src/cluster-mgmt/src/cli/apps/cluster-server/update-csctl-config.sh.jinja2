#!/usr/bin/env bash

set -e

SCRIPT_PATH=$(dirname "$0")
cd "$SCRIPT_PATH"
source "../pkg-common.sh"

if [ -z "$namespace" ]; then
  namespace="{{ namespace }}"
fi
system_namespace="{{ system_namespace }}"

if [ "$namespace" != "$system_namespace" ]; then
  echo "Skipping updating csctl config and user auth secret as the current namespace '$namespace' is not the system namespace."
  exit
fi

# At a high level, the csctl config will mostly be different on the mgmt nodes and the user nodes:
# - on the mgmt nodes, we will have a single system NS cert authority if the system NS is deployed with 2.1 bits
# - on the user nodes, we will have whatever NS cert authorities (mostly be user namespaces) we had deployed earlier
if ! $KUBECTL -n "$system_namespace" get ingress cluster-server; then
  echo "error: cluster-server ingress not found, was cluster-server deployed in the system namespace?" >&2
  exit 1
fi

# TODO: is generate_csctl_cfg ok to always run?
config_v2="config_v2"
generate_csctl_cfg "$config_v2" "$system_namespace" "true"
# Ideally we get better atomicity with `mv`, but given csctl usage on the mgmt nodes
# is fairly infrequent, SSH-based copy may be fine. Could update if this turned out
# to be an issue later on.
tmp_file=$(mktemp)
PSCP_MGMT "$config_v2" "$tmp_file"
PSSH_MGMT "$CHMOD a+r $tmp_file && $MV $tmp_file $CFG_DIR/config_v2 || true"

# copy user auth secret
auth_secret="user-auth-secret"
$KUBECTL -n "$namespace" get secret kube-user-auth -ojsonpath='{.data.secret}' | base64 --decode -w 0 > "$auth_secret"
chmod 600 "$auth_secret"
PSSH_MGMT "$MKDIR -p $USER_AUTH_SECRET_DIR"

PSCP_MGMT "$auth_secret" "$tmp_file"
PSSH_MGMT "($MV $tmp_file $USER_AUTH_SECRET_DIR/$auth_secret || true) && $CHMOD 600 $USER_AUTH_SECRET_DIR/$auth_secret"

